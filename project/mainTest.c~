#include <msp430.h>
#include <libTimer.h>
#include "lcdutils.h"
#include "lcddraw.h"

// Constants
#define MAX_NOTES 4           // Maximum number of notes on screen
#define NOTE_WIDTH 10         // Width of a falling note
#define NOTE_HEIGHT 5         // Height of a falling note
#define TARGET_ROW (screenHeight - 10) // Row to hit notes
#define FALL_SPEED 2          // Speed of falling notes
#define SWITCHES 15           // All switches (SW1 | SW2 | SW3 | SW4)

// Switch definitions
#define SW1 1
#define SW2 2
#define SW3 4
#define SW4 8

// Note structure
typedef struct {
  int col;       // Column position
  int row;       // Row position
  char active;   // Whether the note is active
  char switchId; // Corresponding switch (0 = SW1, 1 = SW2, etc.)
} Note;

// Global variables
Note notes[MAX_NOTES];   // Notes array
int score = 0;           // Player score
int fallSpeed = FALL_SPEED; // Speed of falling notes
int switches = 0;        // Current switch states
short redrawScreen = 1;  // Flag to trigger screen redraw

// Function prototypes
void init_notes();
void spawn_note();
void update_notes();
void check_hits();
void draw_notes();
void clear_notes();
void update_shape();
void wdt_c_handler();
void switch_interrupt_handler();
static char switch_update_interrupt_sense();
void switch_init();
void __interrupt_vec(PORT2_VECTOR) Port_2();

// Initialize notes
void init_notes() {
  for (int i = 0; i < MAX_NOTES; i++) {
    notes[i].active = 0; // All notes inactive initially
  }
}

// Spawn a new note
void spawn_note() {
  for (int i = 0; i < MAX_NOTES; i++) {
    if (!notes[i].active) {
      notes[i].col = (i * (screenWidth / MAX_NOTES)) +
	(screenWidth / (2 * MAX_NOTES)) - (NOTE_WIDTH / 2);
      notes[i].row = 0;    // Start at the top
      notes[i].active = 1; // Activate note
      notes[i].switchId = i; // Assign to corresponding switch
      break;
    }
  }
}

// Update notes (move them down)
void update_notes() {
  for (int i = 0; i < MAX_NOTES; i++) {
    if (notes[i].active) {
      notes[i].row += fallSpeed; // Move note down
      if (notes[i].row >= screenHeight) { // Missed note
	notes[i].active = 0; // Deactivate note
	score -= 1;          // Decrease score
      }
    }
  }
}
// Check if a note was hit
void check_hits() {
  for (int i = 0; i < MAX_NOTES; i++) {
    if (notes[i].active && notes[i].row >= TARGET_ROW - NOTE_HEIGHT &&
	notes[i].row <= TARGET_ROW) {
      if (switches & (1 << notes[i].switchId)) { // Switch matches note
	notes[i].active = 0; // Deactivate note
	score += 1;          // Increase score
      }
    }
  }
}

// Draw notes on screen
void draw_notes() {
  for (int i = 0; i < MAX_NOTES; i++) {
    if (notes[i].active) {
      fillRectangle(notes[i].col, notes[i].row, NOTE_WIDTH, NOTE_HEIGHT,
		    COLOR_WHITE);
    }
  }
}

// Clear notes from the screen
void clear_notes() {
  for (int i = 0; i < MAX_NOTES; i++) {
    if (notes[i].active) {
      fillRectangle(notes[i].col, notes[i].row, NOTE_WIDTH, NOTE_HEIGHT,
		    COLOR_BLACK);
    }
  }
}

// Update the shape (graphics)
void update_shape() {
  clear_notes(); // Clear previous frame
  draw_notes();  // Draw current frame

  // Display score
  char scoreStr[10];
  sprintf(scoreStr, "Score: %d", score);
  drawString5x7(5, 5, scoreStr, COLOR_GREEN, COLOR_BLACK);
}

// Switch interrupt handler
void switch_interrupt_handler() {
  char p2val = switch_update_interrupt_sense();
  switches = ~p2val & SWITCHES; // Update switches state
  check_hits();                 // Check if a note was hit
}

// Watchdog timer interrupt handler
void wdt_c_handler() {
  static int spawnTimer = 0;

  spawnTimer++;
  if (spawnTimer >= 50) { // Spawn a new note every 500ms
    spawn_note();
    spawnTimer = 0;
  }

  update_notes();    // Move notes down
  check_hits();       // Check for hits
  redrawScreen = 1;   // Trigger screen redraw
}

// Initialize switches
void switch_init() {
  P2REN |= SWITCHES;  // Enable resistors for switches
  P2IE |= SWITCHES;   // Enable interrupts for switches
  P2OUT |= SWITCHES;  // Pull-ups for switches
  P2DIR &= ~SWITCHES; // Set switches as inputs
  switch_update_interrupt_sense();
}

// Update switch interrupt sense
static char switch_update_interrupt_sense() {
  char p2val = P2IN;
  P2IES |= (p2val & SWITCHES);  // Sense falling edge
  P2IES &= (p2val | ~SWITCHES); // Sense rising edge
  return p2val;
}

// Main function
void main() {
  configureClocks();
  lcd_init();
  switch_init();
  init_notes();

  enableWDTInterrupts(); // Enable periodic interrupts
  or_sr(0x8);            // Enable global interrupts (GIE)

  clearScreen(COLOR_BLACK); // Start with a black screen
  while (1) {
    if (redrawScreen) {
      redrawScreen = 0;
      update_shape(); // Update screen
    }
    or_sr(0x10); // Enter low-power mode
  }
}

// Port 2 interrupt handler
void __interrupt_vec(PORT2_VECTOR) Port_2() {
  if (P2IFG & SWITCHES) {     // Did a switch cause the interrupt?
    P2IFG &= ~SWITCHES;     // Clear pending switch interrupts
    switch_interrupt_handler();
  }
}
